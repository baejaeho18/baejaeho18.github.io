---
layout: post
title: "[EIP] 필기 1일차"
category: study
tags: eip
---

필기 시험 날짜는 2024년 5월 9일(목)이다.
너무 늦게 공부를 시작했나 싶긴 하지만, 남은 이틀 동안 최대한 빠르게 많이 훑어보고 시험장에 들어가보자.
공부 재료는 역시나 [시나공]이다. 오늘 처음 회원가입하고 써보는데 무료로 많은 자료와 기출문제들이 있어서 이틀 동안 소화하기 알맞을 것 같다. 

목표는 1일차에 쉬운 1,2,3과목에 대해 개념 훑어보기를 끝내고 확인차 기출을 풀어보는 것이다.
2일차 목표는 4과목을 기출 3회 정도 돌려보고, 5과목은 정리하면서 이해하기. 기출도 2회 정도는 풀 수 있으면 좋겠다.

## 1. 소프트웨어 설계
그럼, 1과목부터 시작!
소프트웨어 공학은 아쉽게도 학부 과정에서 듣지 못해서 조금 시간이 걸릴 수도 있을 것 같다. 
소프트웨어 공학은 소프트웨어의 위험(risk)를 관리하기 위해 연구된 학문을 말한다.
품질 및 생상성 향상을 위해 여러가지 방법론과 도구, 관리 기법들이 만들어졌다.
가장 기본적인 원칙은 지속적인 검증과 기록이다.
<!--more-->
### 1.1 개발 프로세스 모델
개발 방법론의 바탕이 되는 스프트웨어 생명 주기는 소프트웨어 정의, 운용, 유지보수 등의 과정을 단계별로 나뉜다. 각 단계들과 그 산출물로 **생명 주기 모형**(혹은 프로세스 모형)이 표현된다. 
* 폭포수(Waterfall) 모형 : 각 개발 단계를 철저히 검증 및 결과물을 산출한 후, 다음 단계를 진행하는 선형 순차적 모형이다. <br>
(타당성검토 -> 계획 -> 요구분석 -> 설계 -> 구현 -> 시험 -> 유지보수)
* 나선형(Spiral) 모형 : 여러번 개발 과정을 거쳐 점진적으로 개발해 위험을 최소화한다.<br>
(계획수립 -> 위험분석 -> 개발/검증 -> 고객 평가) -> (계획수립 ...)
* 애자일(Agile) 모형 : 고객과의 소통에 초점을 맞춰 요구사항 변화에 유연하게 대응하도록 일정한 주기를 반복한다.
(ex: Scrum, XP, Kanban, Lean, Crystal, ASD, FDD, DSDM, DAD 등)

Agile 개발은 프로세스나 도구보다는 협엽과 상호작용에 더 가치를 둔다. 문서보다 SW에, 계획보다 변화에 반응하는 것에 집중한다.
스크럼 개발 프로세스의 경우, 매일 회의에서 모든 요구사항이 담긴 백로그를 기반으로 단기 일정을 수립하고 테스팅을 수행한다. 이 과정을 스프린트(sprint)라고 부른다.
XP(eXtrem Programming)의 경우 수시로 발생하는 요구사항에 대응하기 위해 짧고 반복적인 개발 주기로 개발 생산성을 높인다. small releases를 반복하면서 단순한 설계를 CI(지속적 통합)하여 design refactoring(improvement)한다. 이를 위해, 구현보다 테스트 케이스를 먼저 작성하고 자동화된 테스팅 도구를 사용하는 **TDD**를 사용한다.

### 1.2 요구사항 확인
요구사항은 소프트웨어가 제공하는 **서비스**(기능)에 대한 설명과 정상적으로 운영되기 위해 필요한 **제약조건**(비기능) 등을 말한다.
이러한 요구사항을 도출(elicitation), 분석(analysis), 명세(specification), 검증(validation)하는 활동을 요구사항 개발 프로세스라고 부른다.
산출물인 요구사항 명세는 수학적 표기법을 따르는 **정형 명세 기법**이나 자연어/다이어그램으로 이루어진 **비정형 명세 기법**으로 작성된다.
명세화를 위해서 요구사항을 분석할 때, UML, DFD(자료흐름도), DD(자료사전), ERD(개체관계도) 등의 도구를 사용한다.
UML(Unified Modeling Language)는 개발자와 고객/사용자의 의사소통을 위해 표준화한 객체지향 모델링 언어이다. 사물과 관계(연관/집합/포함/일반화/의존/실체화)로 객체지향 시스템 구조를 다이어그램으로 작성할 수 있다.
DFD(Data Flow Diagram)은 데이터의 흐름과 변환 과정, 기능을 다이어그램으로 기술하여 자료흐름그래프/버블차트라고도 불린다.
DD(Data Dictionary)는 DFD의 자료를 설명한 메타데이터를 기록한다.
요구사항 분석을 자동화한 도구로는 SADT, SREM, PSL/PSA, TAGS 등이 있다.

모듈을 통합하려면 먼저 현행시스템을 이해해야 한다. 시스템의 기능과 구성, 인터페이스를 파악하는 것이 먼저이고, 설계와 소프트웨어의 구성을 명시한 후, 하드웨어와 네트워크 구성을 작성해야한다.
반드시 파악해야할 시스템에는 OS, DBMS, WAS 등이 있다.
**OS**는 하드웨어와 사용자 간의 인터페이스로 응용 프로그램이 동작하는 환경을 제공한다. Windows, UNIX, Linux, MacOS, iOS, Android 등이 있다.
**DBMS**는 데이터베이스와 사용자 간의 인터페이스로, 정보를 생성하고 관리한다. 모든 응용 프로그램이 데이터를 공유하도록, 파일 시스템의 종속성과 중복성 문제를 해결한 시스템이다. Oracle, MySQL, SQLite, MongoDB, Redis 등이 있다.
**WAS**는 정적인 웹서버와 달리, 사용자의 요구에 동적으로 대응하기 위해 사용되는 미들웨어이다. 데이터 접근, 세션 관리, 트랜잭션 관리 등을 주로 데이터베이스와 연동하여 수행한다. Tomcat 등이 있다.

* Diagram : 사물과 관계를 가시화된 도형으로 표현한다.
    - 구조적(structural) diagram : class, object, component, deployment, ...
    - 기능적(behavioral) diagram
        - use-case : 사용자(actor) 관점의 기능
        - sequence : 시간순으로 상호 작용하는 과정 with 메시지
        - communication, state, activity, interaction overview, timing, ...

* UI : 사용자 인터페이스는 만족도에 가장 큰 영향을 끼쳐 변경이 가장 잦다.
크게 CommandLI, GraphicalUI, NaturalUI, VoiceUI, OrganicUI 등으로 나뉜다.
UI 설계 도구에는 Wireframe, Mockup, Story-Board, Prototype, Use-case 등이 있다.

실사용자 입장에서 사용하기 쉽고, 오류파악이 쉽도록 검증해야 한다. 이를 위해 기능성, 신뢰성, 사용성, 효율성, 유지보수성, 이식성 등의 품질 요구사항이 존재한다.

### 1.3 애플리케이션 설계
UI와 diagram 등으로 요구사항에 대한 대비가 끝났다면, 이제 소프트웨어를 설계해야 한다.
시스템의 전체 구조를 계층적으로 설계한 후, 상세한 내부 구조 및 동작을 설계한다.
주어진 문제를 상위 개념부터(단계적 분해), 세분화하여(추상화), 기능과 정보를 모듈 단위로(모듈화) 나눠 독립되게(정보은닉) 설계해야 한다.
언뜻 보기에도 복잡하기에, 참고할 수 있는 전형적인 아키텍쳐 패턴들이 마련되어 있다. OSI 참조 모델 같은 Layers 패턴과 일대다 component를 연결하는 client-server 패턴 등이 가장 단순한 예시이다.

* 파이프-필터 패턴 : 
데이터 스트림의 각 단계를 filter로 캡슐화하여 pipe로 전송한다.
재사용성과 확장성이 좋아 다양한 파이프라인을 구축하기에 용이하다.

* 모델-뷰-컨트롤러(MVC) 패턴 : 
핵심 기능과 데이터를 보관하는 Model과 정보를 표시하는 View, 사용자의 입력을 처리하는 Controller로 서로 독립되어 구성된다.
여러 개의 뷰를 필요로 하는 대화형 애플리케이션에 용이하다.

변화하는 요구사항들에 대응하여 위와 같은 아키텍쳐 패턴에 따라 설계하기 위해 객체지향(Object-Oriented) 개념이 만들어졌다.
각 객체는 동작(함수)과 정보(데이터)를 캡슐화한 모듈이다. 객체(object, instance)를 정의하는 class는 곧 그 객체의 type이다. 객체들은 **상속**과 **다형성**을 통해 재사용성을 높일 수 있다.
시스템의 변경과 확장에 대처하기 위해 다음 다섯가지 기본 원칙(SOLID)이 제시되었다.
1) Single Responsibility : 객체는 하나의 책임만 가지도록
2) Open-Closed : 코드 변경 없이 기능을 추가할 수 있도록
3) Liskov Substitutioin : 부모가 가능한 것은 자식도 가능하도록
4) Interface Segregation : 필요 없는 인터페이스와는 독립되도록
5) Dependency Inversion : 추상성이 높은 클래스를 의존하도록

모듈화 정도를 판단하는 기준에는 결합도와 응집도, Fan-In/Out이 있다.
결합도(coupling)은 여러 모듈 간의 의존 정도를 나타낸다. 이상적인 순서대로 data-stamp-control-external-common-content 이다. stamp는 자료구조까지 일치해야하는 경우이다.
응집도(cohesion)은 한 모듈 내의 기능이 관련되어 있는 정도를 나타낸다. 이상적인 순서대로 functional-sequential-communication-procedural-temporal-logical-coincidental이다.
시스템의 복잡도를 판단하기 위해서 해당 모듈에서 호출하는 모듈의 수(Fan-In)와 해당 모듈이 호출되는 모듈의 수(Fan-out)이 쓰인다. In이 높을수록, Out이 낮을수록 좋다.
재사용성을 더 높이기 위해, 여러 프로그램에서도 사용할 수 있는 공통 모듈이 존재한다.
결합도가 낮고 응집도가 높아야 하며, 누구나 사용하기 쉽게 명세가 명확하게 작성되어야 한다.

* code 부여 체계 : 
데이터를 처리하는 과정에서 간소화 및 표준화하기 위해 특정 코드들을 부여하곤 한다. 순차코드, 블록코드(번호부), 10진코드(도서분류), 그룹분류코드(버전), 연상코드(약호), 표의숫자코드(수치), 합성코드 등이 있다.

전체 시스템 구조가 아키텍처 패턴으로 모델화되었다면, 독립적인 컴포넌트들과 그 관계(interface)를 설계하기 위해 디자인 패턴이 쓰인다.
검증된 범용적인 패턴 스타일들이기에 구조 파악이 용이하고, 유연한 대처가 가능해 생산성을 높인다.
그중 GoF 디자인 패턴은 크게 5개 생성 패턴과 7개 구조 패턴, 11개 행위 패턴으로 구성되어 있다.


## 2. 소프트웨어 개발
### 2.1 자료구조
자료구조는 array, stack, queue, linear list 등의 선형구조와 tree, graph 등의 비선형구조로 나뉜다.
List는 배열처럼 연속적으로 저장되는 contiguous list와 각 노드에 값과 다음 노드의 주소 값을 저장하는 linked list로 나뉜다. 메모리 효율은 연속리스트가 좋지만, 노드의 삽입/삭제 등의 작업은 linked list가 유리하다.
Stack은 LIFO(후입선출) 방식의 리스트 top 포인터 하나가 있다. 주로 interupt, function call, return address, 수식표기 등에 사용된다.
Queue는 FIFO(선입선출) 방식의 리스트로 시작과 끝을 표시하는 두 개의 포인터가 있다.
Graph는 무방향과 방향으로 나뉘는데, 최대 간선 수는 무방향그래프에서 n(n-1)/2이고, 방향그래프에서는 n(n-1)이다.
Tree는 cycle을 이루지 않도록 구성한 graph이다. Root 노드(level 1)부터 leaf 노드까지의 노드 개수가 depth이다. 각 노드의 자식 노드 개수를 degree라고 부른다.
읽는 방식에 따라 preorder(A-B-C), inorder(B-A-C), postorder(B-C-A)로 나뉜다.
이 표기법은 수식에서도 유사하게 나타난다. prefix(+AB), infix(A+B), postfix(AB+)와 같다. stack에서 사용하기 위해 prefix나 postfix와 같이 표기한다.

* Selection Sort
* Bubble Sort
* Quick Sort : conquer and divide 방식을 따른다. 평균적으로 O(nlogn), 최악의 경우 O(n^2)이다.
* Heap Sort : 완전이진트리를 이용해 heap tree로 변환하여 정렬한다. O(nlogn)이다.
* Merge Sort : O(n^2)이다.
* binary search : 순서화된 파일을 둘로 나누어가며 key를 검색
* Hashing 함수 : 제산법, 제곱법, 폴딩법, radix, 대수적코딩, 계수분석법, 무작위 등이 쓰인다.



## 3. 데이터베이스 구축
163 DBMS는


## 4. 프로그래밍 언어 활용
232 

## 5. 정보시스템 구축 관리
315  


<!-- Links -->
[시나공]: https://www.sinagong.co.kr/pds